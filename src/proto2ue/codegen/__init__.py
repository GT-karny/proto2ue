"""Template rendering for proto2ue Unreal Engine bindings."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Protocol

from ..type_mapper import UEEnum, UEField, UEMessage, UEProtoFile


@dataclass(frozen=True, slots=True)
class GeneratedFile:
    """Represents a generated output file from the renderer."""

    name: str
    content: str


class ITemplateRenderer(Protocol):
    """Interface for renderers that convert :class:`UEProtoFile` objects into files."""

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        """Render the provided :class:`UEProtoFile` into zero or more files."""
        raise NotImplementedError


class DefaultTemplateRenderer:
    """Simple renderer that produces a header and source file per proto file."""

    def __init__(
        self,
        *,
        header_suffix: str = ".proto2ue.h",
        source_suffix: str = ".proto2ue.cpp",
    ) -> None:
        self._header_suffix = header_suffix
        self._source_suffix = source_suffix

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        base_name = self._base_name_for(ue_file.name)
        header_name = f"{base_name}{self._header_suffix}"
        source_name = f"{base_name}{self._source_suffix}"
        registration_symbol = self._registration_symbol(base_name)
        header_content = self._render_header(header_name, ue_file)
        source_content = self._render_source(
            header_name, registration_symbol, ue_file
        )
        return [
            GeneratedFile(name=header_name, content=header_content),
            GeneratedFile(name=source_name, content=source_content),
        ]

    def _base_name_for(self, proto_name: str) -> str:
        if proto_name.endswith(".proto"):
            return proto_name[:-6]
        return proto_name

    def _render_header(self, header_name: str, ue_file: UEProtoFile) -> str:
        lines: List[str] = []
        lines.append("#pragma once")
        lines.append("")
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append("")
        lines.append('#include "CoreMinimal.h"')
        generated_include = self._generated_header_include(header_name)
        if generated_include is not None:
            lines.append(f'#include "{generated_include}"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        for depth, namespace in enumerate(namespace_stack):
            indent = "    " * depth
            lines.append(f"{indent}namespace {namespace} {{")
        if namespace_stack:
            lines.append("")

        enums = self._collect_enums(ue_file)
        for enum in enums:
            lines.extend(self._render_enum(enum, indent_level=len(namespace_stack)))
            lines.append("")

        messages = self._collect_messages(ue_file)
        for idx, message in enumerate(messages):
            lines.extend(self._render_message(message, indent_level=len(namespace_stack)))
            if idx != len(messages) - 1:
                lines.append("")

        if namespace_stack:
            lines.append("")
            for depth in reversed(range(len(namespace_stack))):
                indent = "    " * depth
                namespace = namespace_stack[depth]
                lines.append(f"{indent}}}  // namespace {namespace}")

        return "\n".join(lines) + "\n"

    def _generated_header_include(self, header_name: str) -> str | None:
        if not header_name.endswith(".h"):
            return None
        return f"{header_name[:-2]}.generated.h"

    def _render_source(
        self, header_name: str, registration_symbol: str, ue_file: UEProtoFile
    ) -> str:
        lines: List[str] = []
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append(f'#include "{header_name}"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        for depth, namespace in enumerate(namespace_stack):
            indent = "    " * depth
            lines.append(f"{indent}namespace {namespace} {{")
        if namespace_stack:
            lines.append("")

        indent = "    " * len(namespace_stack)
        lines.append(f"{indent}namespace proto2ue {{")
        lines.append(
            f"{indent}    void {registration_symbol}() {{}}"
        )
        lines.append(f"{indent}}}  // namespace proto2ue")

        if namespace_stack:
            lines.append("")
            for depth in reversed(range(len(namespace_stack))):
                indent = "    " * depth
                namespace = namespace_stack[depth]
                lines.append(f"{indent}}}  // namespace {namespace}")

        return "\n".join(lines) + "\n"

    def _render_enum(self, enum: UEEnum, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        specifiers = self._format_macro_specifiers(
            blueprint=enum.blueprint_type,
            specifiers=enum.specifiers,
            category=enum.category,
            metadata=enum.metadata,
        )
        if specifiers:
            macro_line = f"{indent}UENUM{specifiers}"
        else:
            macro_line = f"{indent}UENUM()"
        lines = [macro_line]
        lines.append(f"{indent}enum class {enum.ue_name} : int32 {{")
        for value in enum.values:
            lines.append(f"{indent}    {value.name} = {value.number},")
        lines.append(f"{indent}}};")
        return lines

    def _registration_symbol(self, base_name: str) -> str:
        """Create a unique registration function name for a generated source file."""

        import re

        sanitized = re.sub(r"[^0-9A-Za-z_]", "_", base_name)
        if not sanitized:
            sanitized = "file"
        if sanitized[0].isdigit():
            sanitized = f"_{sanitized}"
        return f"RegisterGeneratedTypes_{sanitized}"

    def _render_message(self, message: UEMessage, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        struct_specifiers = self._format_macro_specifiers(
            blueprint=message.blueprint_type,
            specifiers=message.struct_specifiers,
            category=message.category,
            metadata=message.struct_metadata,
        )
        lines: List[str] = []
        if struct_specifiers:
            lines.append(f"{indent}USTRUCT{struct_specifiers}")
        else:
            lines.append(f"{indent}USTRUCT()")
        lines.append(f"{indent}struct {message.ue_name} {{")
        lines.append(f"{indent}    GENERATED_BODY()")
        if message.fields:
            for field in message.fields:
                specifiers = self._format_property_specifiers(field)
                if specifiers is not None:
                    if specifiers:
                        lines.append(f"{indent}    UPROPERTY({specifiers})")
                    else:
                        lines.append(f"{indent}    UPROPERTY()")
                lines.append(f"{indent}    {field.ue_type} {field.name}{{}};")
        else:
            lines.append(f"{indent}    // No fields declared.")
        for oneof in message.oneofs:
            case_names = ", ".join(case.field.name for case in oneof.cases)
            lines.append(f"{indent}    // oneof {oneof.name}: {case_names}")
        lines.append(f"{indent}}};")
        return lines

    def _format_macro_specifiers(
        self,
        *,
        blueprint: bool,
        specifiers: List[str],
        category: str | None,
        metadata: Dict[str, str],
    ) -> str:
        items: List[str] = []
        if blueprint:
            items.append("BlueprintType")
        items.extend(self._dedupe_preserve_order(specifiers))
        meta_entries: List[str] = []
        metadata_items = metadata or {}
        if metadata_items:
            meta_entries.extend(
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(metadata_items.items())
            )
        if category and "Category" not in metadata_items:
            meta_entries.append(
                f'Category="{self._escape_metadata_value(category)}"'
            )
        if meta_entries:
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items:
            return ""
        return f"({', '.join(items)})"

    def _format_property_specifiers(self, field: UEField) -> str | None:
        items: List[str] = []
        if field.blueprint_exposed:
            items.append("BlueprintReadOnly" if field.blueprint_read_only else "BlueprintReadWrite")
        items.extend(self._dedupe_preserve_order(field.uproperty_specifiers))
        if field.category:
            items.append(
                f'Category="{self._escape_metadata_value(field.category)}"'
            )
        if field.uproperty_metadata:
            meta_entries = [
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(field.uproperty_metadata.items())
            ]
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items and not field.blueprint_exposed:
            return ""
        return ", ".join(items)

    def _escape_metadata_value(self, value: str) -> str:
        """Escape a value for safe inclusion in a C++ string literal."""

        escaped_chars = {
            "\\": "\\\\",
            '"': '\\"',
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
        }
        return "".join(escaped_chars.get(ch, ch) for ch in value)

    def _dedupe_preserve_order(self, specifiers: Iterable[str]) -> List[str]:
        seen = set()
        result: List[str] = []
        for specifier in specifiers:
            if specifier in seen:
                continue
            seen.add(specifier)
            result.append(specifier)
        return result

    def _collect_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        collected: List[UEMessage] = []

        def visit(message: UEMessage) -> None:
            for nested in message.nested_messages:
                visit(nested)
            collected.append(message)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _collect_enums(self, ue_file: UEProtoFile) -> List[UEEnum]:
        collected: List[UEEnum] = []
        collected.extend(ue_file.enums)

        def visit(message: UEMessage) -> None:
            collected.extend(message.nested_enums)
            for nested in message.nested_messages:
                visit(nested)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _namespace_stack(self, package: str | None) -> List[str]:
        if not package:
            return []
        return package.split(".")


__all__ = [
    "DefaultTemplateRenderer",
    "GeneratedFile",
    "ITemplateRenderer",
]
