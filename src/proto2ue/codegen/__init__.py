"""Template rendering for proto2ue Unreal Engine bindings."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Protocol

from ..type_mapper import (
    UEEnum,
    UEField,
    UEMessage,
    UEOptionalWrapper,
    UEProtoFile,
)


@dataclass(frozen=True, slots=True)
class GeneratedFile:
    """Represents a generated output file from the renderer."""

    name: str
    content: str


class ITemplateRenderer(Protocol):
    """Interface for renderers that convert :class:`UEProtoFile` objects into files."""

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        """Render the provided :class:`UEProtoFile` into zero or more files."""
        raise NotImplementedError


class IncludeManager:
    """Utility class to collect and render C++ include directives."""

    def __init__(self) -> None:
        self._engine_includes: List[str] = []
        self._project_includes: List[str] = []
        self._system_includes: List[str] = []

    def add_engine(self, include: str) -> None:
        self._add_unique(self._engine_includes, include)

    def add_project(self, include: str) -> None:
        self._add_unique(self._project_includes, include)

    def add_system(self, include: str) -> None:
        self._add_unique(self._system_includes, include)

    def render(self) -> List[str]:
        lines: List[str] = []
        if self._engine_includes:
            lines.extend(f'#include "{include}"' for include in self._engine_includes)
        if self._project_includes:
            if lines:
                lines.append("")
            lines.extend(f'#include "{include}"' for include in self._project_includes)
        if self._system_includes:
            if lines:
                lines.append("")
            lines.extend(f"#include <{include}>" for include in self._system_includes)
        return lines

    def _add_unique(self, target: List[str], include: str) -> None:
        if not include or include in target:
            return
        target.append(include)


class DefaultTemplateRenderer:
    """Simple renderer that produces a header and source file per proto file."""

    def __init__(
        self,
        *,
        header_suffix: str = ".proto2ue.h",
        source_suffix: str = ".proto2ue.cpp",
    ) -> None:
        self._header_suffix = header_suffix
        self._source_suffix = source_suffix

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        base_name = self._base_name_for(ue_file.name)
        header_name = f"{base_name}{self._header_suffix}"
        source_name = f"{base_name}{self._source_suffix}"
        registration_symbol = self._registration_symbol(base_name)
        header_content = self._render_header(header_name, ue_file)
        source_content = self._render_source(header_name, registration_symbol, ue_file)
        return [
            GeneratedFile(name=header_name, content=header_content),
            GeneratedFile(name=source_name, content=source_content),
        ]

    def _base_name_for(self, proto_name: str) -> str:
        if proto_name.endswith(".proto"):
            return proto_name[:-6]
        return proto_name

    def _render_header(self, header_name: str, ue_file: UEProtoFile) -> str:
        lines: List[str] = []
        lines.append("#pragma once")
        lines.append("")
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append("")
        lines.append('#include "CoreMinimal.h"')
        generated_include = self._generated_header_include(header_name)
        dependency_includes = self._dependency_includes(ue_file)

        include_block: List[str] = []
        include_block.extend(f'#include "{include}"' for include in dependency_includes)
        if generated_include is not None:
            include_block.append(f'#include "{generated_include}"')

        if include_block:
            lines.append("")
            lines.extend(include_block)

        enums = self._collect_enums(ue_file)
        messages = self._collect_messages(ue_file)

        for enum in enums:
            if lines and lines[-1] != "":
                lines.append("")
            lines.extend(self._render_enum(enum, indent_level=0))
            lines.append("")

        # fmt: off
        optional_wrappers = self._collect_optional_wrappers(ue_file)
        rendered_wrappers: set[int] = set()

        messages = self._sorted_messages(ue_file)
        message_names = {message.ue_name for message in messages}
        rendered_messages: set[str] = set()

        def emit_wrapper(
            wrapper: UEOptionalWrapper, *, current_message: str | None = None
        ) -> None:
            wrapper_id = id(wrapper)
            if wrapper_id in rendered_wrappers:
                return
            base_type = wrapper.base_type
            if (
                base_type in message_names
                and base_type not in rendered_messages
                and base_type != current_message
            ):
                raise RuntimeError(
                    "Optional wrapper emitted before base message definition: "
                    f"{wrapper.ue_name} depends on {base_type}"
                )
            if lines and lines[-1] != "":
                lines.append("")
            lines.extend(self._render_optional_wrapper(wrapper, indent_level=0))
            lines.append("")
            rendered_wrappers.add(wrapper_id)

        for idx, message in enumerate(messages):
            needed_wrappers: List[UEOptionalWrapper] = []
            for field in message.fields:
                if field.optional_wrapper is not None:
                    needed_wrappers.append(field.optional_wrapper)
            seen_wrapper_ids: set[int] = set()
            unique_wrappers: List[UEOptionalWrapper] = []
            for wrapper in needed_wrappers:
                wrapper_id = id(wrapper)
                if wrapper_id in seen_wrapper_ids:
                    continue
                seen_wrapper_ids.add(wrapper_id)
                unique_wrappers.append(wrapper)
            deferred_wrappers: List[UEOptionalWrapper] = []
            for wrapper in unique_wrappers:
                if wrapper.base_type == message.ue_name:
                    deferred_wrappers.append(wrapper)
                    continue
                emit_wrapper(wrapper, current_message=message.ue_name)

            if lines and lines[-1] != "":
                lines.append("")
            lines.extend(self._render_message(message, indent_level=0))
            rendered_messages.add(message.ue_name)

            for wrapper in deferred_wrappers:
                emit_wrapper(wrapper)
            if idx != len(messages) - 1 and lines and lines[-1] != "":
                lines.append("")

        for wrapper in optional_wrappers:
            if id(wrapper) not in rendered_wrappers:
                emit_wrapper(wrapper)
        # fmt: on

        while lines and lines[-1] == "":
            lines.pop()

        return "\n".join(lines) + "\n"

    def _generated_header_include(self, header_name: str) -> str | None:
        if not header_name.endswith(".h"):
            return None
        return f"{header_name[:-2]}.generated.h"

    def _dependency_includes(self, ue_file: UEProtoFile) -> List[str]:
        includes: List[str] = []
        seen: set[str] = set()

        for message in self._collect_messages(ue_file):
            for field in message.fields:
                for dependency in field.dependent_files:
                    include = f"{self._base_name_for(dependency)}{self._header_suffix}"
                    if include in seen:
                        continue
                    seen.add(include)
                    includes.append(include)

        return includes

    def _render_source(
        self, header_name: str, registration_symbol: str, ue_file: UEProtoFile
    ) -> str:
        lines: List[str] = []
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append(f'#include "{header_name}"')
        lines.append("")

        lines.append(f"void {registration_symbol}() {{}}")

        return "\n".join(lines) + "\n"

    def _render_enum(self, enum: UEEnum, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        specifiers = self._format_macro_specifiers(
            blueprint=enum.blueprint_type,
            specifiers=enum.specifiers,
            category=enum.category,
            metadata=enum.metadata,
        )
        if specifiers:
            macro_line = f"{indent}UENUM{specifiers}"
        else:
            macro_line = f"{indent}UENUM()"
        lines = [macro_line]
        lines.append(f"{indent}enum class {enum.ue_name} : int32 {{")
        for value in enum.values:
            lines.append(f"{indent}    {value.name} = {value.number},")
        lines.append(f"{indent}}};")
        return lines

    def _render_optional_wrapper(
        self, wrapper: UEOptionalWrapper, *, indent_level: int
    ) -> List[str]:
        indent = "    " * indent_level
        lines: List[str] = []
        struct_specifiers = self._format_macro_specifiers(
            blueprint=wrapper.blueprint_type,
            specifiers=[],
            category=None,
            metadata={},
        )
        if struct_specifiers:
            lines.append(f"{indent}USTRUCT{struct_specifiers}")
        else:
            lines.append(f"{indent}USTRUCT()")
        lines.append(f"{indent}struct {wrapper.ue_name} {{")
        lines.append(f"{indent}    GENERATED_BODY()")
        if wrapper.blueprint_type:
            lines.append(f"{indent}    UPROPERTY(BlueprintReadWrite)")
        else:
            lines.append(f"{indent}    UPROPERTY()")
        lines.append(f"{indent}    bool {wrapper.is_set_member} = false;")
        if wrapper.value_blueprint_exposed:
            lines.append(f"{indent}    UPROPERTY(BlueprintReadWrite)")
        else:
            lines.append(f"{indent}    UPROPERTY()")
        lines.append(f"{indent}    {wrapper.base_type} {wrapper.value_member}{{}};")
        lines.append(f"{indent}}};")
        return lines

    def _registration_symbol(self, base_name: str) -> str:
        """Create a unique registration function name for a generated source file."""

        import re

        sanitized = re.sub(r"[^0-9A-Za-z_]", "_", base_name)
        if not sanitized:
            sanitized = "file"
        if sanitized[0].isdigit():
            sanitized = f"_{sanitized}"
        return f"RegisterGeneratedTypes_{sanitized}"

    def _render_message(self, message: UEMessage, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        struct_specifiers = self._format_macro_specifiers(
            blueprint=message.blueprint_type,
            specifiers=message.struct_specifiers,
            category=message.category,
            metadata=message.struct_metadata,
        )
        lines: List[str] = []
        if struct_specifiers:
            lines.append(f"{indent}USTRUCT{struct_specifiers}")
        else:
            lines.append(f"{indent}USTRUCT()")
        lines.append(f"{indent}struct {message.ue_name} {{")
        lines.append(f"{indent}    GENERATED_BODY()")
        if message.fields:
            for field in message.fields:
                specifiers = self._format_property_specifiers(field)
                if specifiers is not None:
                    if specifiers:
                        lines.append(f"{indent}    UPROPERTY({specifiers})")
                    else:
                        lines.append(f"{indent}    UPROPERTY()")
                lines.append(f"{indent}    {field.ue_type} {field.name}{{}};")
        else:
            lines.append(f"{indent}    // No fields declared.")
        for oneof in message.oneofs:
            case_names = ", ".join(case.field.name for case in oneof.cases)
            lines.append(f"{indent}    // oneof {oneof.name}: {case_names}")
        lines.append(f"{indent}}};")
        return lines

    def _format_macro_specifiers(
        self,
        *,
        blueprint: bool,
        specifiers: List[str],
        category: str | None,
        metadata: Dict[str, str],
    ) -> str:
        items: List[str] = []
        if blueprint:
            items.append("BlueprintType")
        items.extend(self._dedupe_preserve_order(specifiers))
        meta_entries: List[str] = []
        metadata_items = metadata or {}
        if metadata_items:
            meta_entries.extend(
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(metadata_items.items())
            )
        if category and "Category" not in metadata_items:
            meta_entries.append(f'Category="{self._escape_metadata_value(category)}"')
        if meta_entries:
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items:
            return ""
        return f"({', '.join(items)})"

    def _format_property_specifiers(self, field: UEField) -> str | None:
        items: List[str] = []
        if field.blueprint_exposed:
            items.append(
                "BlueprintReadOnly"
                if field.blueprint_read_only
                else "BlueprintReadWrite"
            )
        items.extend(self._dedupe_preserve_order(field.uproperty_specifiers))
        if field.category:
            items.append(f'Category="{self._escape_metadata_value(field.category)}"')
        if field.uproperty_metadata:
            meta_entries = [
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(field.uproperty_metadata.items())
            ]
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items and not field.blueprint_exposed:
            return ""
        return ", ".join(items)

    def _escape_metadata_value(self, value: str) -> str:
        """Escape a value for safe inclusion in a C++ string literal."""

        escaped_chars = {
            "\\": "\\\\",
            '"': '\\"',
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
        }
        return "".join(escaped_chars.get(ch, ch) for ch in value)

    def _dedupe_preserve_order(self, specifiers: Iterable[str]) -> List[str]:
        seen = set()
        result: List[str] = []
        for specifier in specifiers:
            if specifier in seen:
                continue
            seen.add(specifier)
            result.append(specifier)
        return result

    def _render_header_includes(self, ue_file: UEProtoFile) -> List[str]:
        manager = IncludeManager()

        for include in self._collect_engine_includes(ue_file):
            manager.add_engine(include)

        for include in self._collect_dependency_headers(ue_file):
            manager.add_project(include)

        return manager.render()

    def _collect_engine_includes(self, ue_file: UEProtoFile) -> List[str]:
        tokens: set[str] = set()

        for message in self._collect_messages(ue_file):
            for field in message.fields:
                tokens.add(field.base_type)
                tokens.add(field.ue_type)
                if field.map_key_type is not None:
                    tokens.add(field.map_key_type)
                if field.map_value_type is not None:
                    tokens.add(field.map_value_type)
        for wrapper in self._collect_optional_wrappers(ue_file):
            tokens.add(wrapper.base_type)

        includes: set[str] = {"CoreMinimal.h"}
        for token in tokens:
            includes.update(self._engine_includes_for_type(token))

        ordered: List[str] = []
        if "CoreMinimal.h" in includes:
            ordered.append("CoreMinimal.h")
            includes.remove("CoreMinimal.h")
        ordered.extend(sorted(include for include in includes if include))
        return ordered

    def _engine_includes_for_type(self, token: Optional[str]) -> List[str]:
        if not token:
            return []
        includes: set[str] = set()
        if token.startswith("TArray"):
            includes.add("Containers/Array.h")
        if token.startswith("TMap"):
            includes.add("Containers/Map.h")
        if token.startswith("TSet"):
            includes.add("Containers/Set.h")
        if "FString" in token:
            includes.add("Containers/UnrealString.h")
        return sorted(includes)

    def _collect_dependency_headers(self, ue_file: UEProtoFile) -> List[str]:
        dependency_files: set[str] = set()
        for message in self._collect_messages(ue_file):
            for field in message.fields:
                dependency_files.update(field.dependent_files)

        source_file = ue_file.source.name if ue_file.source is not None else None
        filtered = [
            dependency
            for dependency in dependency_files
            if dependency and dependency != source_file
        ]
        return [
            f"{self._base_name_for(dependency)}{self._header_suffix}"
            for dependency in sorted(filtered)
        ]

    def _collect_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        collected: List[UEMessage] = []

        def visit(message: UEMessage) -> None:
            for nested in message.nested_messages:
                visit(nested)
            collected.append(message)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _sorted_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        messages = self._collect_messages(ue_file)
        if not messages:
            return []

        message_map = {message.ue_name: message for message in messages}
        dependencies = {
            message.ue_name: self._message_dependencies(message, message_map)
            for message in messages
        }

        temp_mark: set[str] = set()
        perm_mark: set[str] = set()
        ordered: List[str] = []
        has_cycle = False

        def visit(name: str) -> None:
            nonlocal has_cycle
            if name in perm_mark or has_cycle:
                return
            if name in temp_mark:
                has_cycle = True
                return
            temp_mark.add(name)
            for dep in dependencies.get(name, []):
                visit(dep)
            temp_mark.remove(name)
            perm_mark.add(name)
            ordered.append(name)

        for message in messages:
            if message.ue_name not in perm_mark:
                visit(message.ue_name)

        if has_cycle:
            return messages

        return [message_map[name] for name in ordered if name in message_map]

    def _message_dependencies(
        self, message: UEMessage, message_map: Dict[str, UEMessage]
    ) -> List[str]:
        dependencies: List[str] = []

        def record(candidate: Optional[str]) -> None:
            if candidate and candidate in message_map and candidate != message.ue_name:
                dependencies.append(candidate)

        for field in message.fields:
            for candidate in self._field_dependency_types(field):
                record(candidate)

        return self._dedupe_preserve_order(dependencies)

    def _field_dependency_types(self, field: UEField) -> List[str]:
        candidates: List[str] = []
        candidates.append(field.base_type)
        if field.map_key_type is not None:
            candidates.append(field.map_key_type)
        if field.map_value_type is not None:
            candidates.append(field.map_value_type)
        if field.optional_wrapper is not None:
            candidates.append(field.optional_wrapper.base_type)
        return [candidate for candidate in candidates if candidate]

    def _collect_enums(self, ue_file: UEProtoFile) -> List[UEEnum]:
        collected: List[UEEnum] = []
        collected.extend(ue_file.enums)

        def visit(message: UEMessage) -> None:
            collected.extend(message.nested_enums)
            for nested in message.nested_messages:
                visit(nested)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _collect_optional_wrappers(
        self, ue_file: UEProtoFile
    ) -> List[UEOptionalWrapper]:
        return list(ue_file.optional_wrappers)

__all__ = [
    "DefaultTemplateRenderer",
    "GeneratedFile",
    "ITemplateRenderer",
]
