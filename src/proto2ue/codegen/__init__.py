"""Template rendering for proto2ue Unreal Engine bindings."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Protocol

from ..type_mapper import UEEnum, UEMessage, UEProtoFile


@dataclass(frozen=True, slots=True)
class GeneratedFile:
    """Represents a generated output file from the renderer."""

    name: str
    content: str


class ITemplateRenderer(Protocol):
    """Interface for renderers that convert :class:`UEProtoFile` objects into files."""

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        """Render the provided :class:`UEProtoFile` into zero or more files."""
        raise NotImplementedError


class DefaultTemplateRenderer:
    """Simple renderer that produces a header and source file per proto file."""

    def __init__(
        self,
        *,
        header_suffix: str = ".proto2ue.h",
        source_suffix: str = ".proto2ue.cpp",
    ) -> None:
        self._header_suffix = header_suffix
        self._source_suffix = source_suffix

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        base_name = self._base_name_for(ue_file.name)
        header_name = f"{base_name}{self._header_suffix}"
        source_name = f"{base_name}{self._source_suffix}"
        registration_symbol = self._registration_symbol(base_name)
        header_content = self._render_header(ue_file)
        source_content = self._render_source(
            header_name, registration_symbol, ue_file
        )
        return [
            GeneratedFile(name=header_name, content=header_content),
            GeneratedFile(name=source_name, content=source_content),
        ]

    def _base_name_for(self, proto_name: str) -> str:
        if proto_name.endswith(".proto"):
            return proto_name[:-6]
        return proto_name

    def _render_header(self, ue_file: UEProtoFile) -> str:
        lines: List[str] = []
        lines.append("#pragma once")
        lines.append("")
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append("")
        lines.append('#include "CoreMinimal.h"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        for depth, namespace in enumerate(namespace_stack):
            indent = "    " * depth
            lines.append(f"{indent}namespace {namespace} {{")
        if namespace_stack:
            lines.append("")

        enums = self._collect_enums(ue_file)
        for enum in enums:
            lines.extend(self._render_enum(enum, indent_level=len(namespace_stack)))
            lines.append("")

        messages = self._collect_messages(ue_file)
        for idx, message in enumerate(messages):
            lines.extend(self._render_message(message, indent_level=len(namespace_stack)))
            if idx != len(messages) - 1:
                lines.append("")

        if namespace_stack:
            lines.append("")
            for depth in reversed(range(len(namespace_stack))):
                indent = "    " * depth
                namespace = namespace_stack[depth]
                lines.append(f"{indent}}}  // namespace {namespace}")

        return "\n".join(lines) + "\n"

    def _render_source(
        self, header_name: str, registration_symbol: str, ue_file: UEProtoFile
    ) -> str:
        lines: List[str] = []
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append(f'#include "{header_name}"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        for depth, namespace in enumerate(namespace_stack):
            indent = "    " * depth
            lines.append(f"{indent}namespace {namespace} {{")
        if namespace_stack:
            lines.append("")

        indent = "    " * len(namespace_stack)
        lines.append(f"{indent}namespace proto2ue {{")
        lines.append(
            f"{indent}    void {registration_symbol}() {{}}"
        )
        lines.append(f"{indent}}}  // namespace proto2ue")

        if namespace_stack:
            lines.append("")
            for depth in reversed(range(len(namespace_stack))):
                indent = "    " * depth
                namespace = namespace_stack[depth]
                lines.append(f"{indent}}}  // namespace {namespace}")

        return "\n".join(lines) + "\n"

    def _render_enum(self, enum: UEEnum, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        lines = [f"{indent}enum class {enum.ue_name} : int32 {{"]
        for value in enum.values:
            lines.append(f"{indent}    {value.name} = {value.number},")
        lines.append(f"{indent}}};")
        return lines

    def _registration_symbol(self, base_name: str) -> str:
        """Create a unique registration function name for a generated source file."""

        import re

        sanitized = re.sub(r"[^0-9A-Za-z_]", "_", base_name)
        if not sanitized:
            sanitized = "file"
        if sanitized[0].isdigit():
            sanitized = f"_{sanitized}"
        return f"RegisterGeneratedTypes_{sanitized}"

    def _render_message(self, message: UEMessage, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        lines = [f"{indent}struct {message.ue_name} {{"]
        if message.fields:
            for field in message.fields:
                lines.append(f"{indent}    {field.ue_type} {field.name}{{}};")
        else:
            lines.append(f"{indent}    // No fields declared.")
        for oneof in message.oneofs:
            case_names = ", ".join(case.field.name for case in oneof.cases)
            lines.append(f"{indent}    // oneof {oneof.name}: {case_names}")
        lines.append(f"{indent}}};")
        return lines

    def _collect_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        collected: List[UEMessage] = []

        def visit(message: UEMessage) -> None:
            for nested in message.nested_messages:
                visit(nested)
            collected.append(message)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _collect_enums(self, ue_file: UEProtoFile) -> List[UEEnum]:
        collected: List[UEEnum] = []
        collected.extend(ue_file.enums)

        def visit(message: UEMessage) -> None:
            collected.extend(message.nested_enums)
            for nested in message.nested_messages:
                visit(nested)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _namespace_stack(self, package: str | None) -> List[str]:
        if not package:
            return []
        return package.split(".")


__all__ = [
    "DefaultTemplateRenderer",
    "GeneratedFile",
    "ITemplateRenderer",
]
