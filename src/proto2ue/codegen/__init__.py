"""Template rendering for proto2ue Unreal Engine bindings."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Protocol

from ..type_mapper import (
    UEEnum,
    UEField,
    UEMessage,
    UEOptionalWrapper,
    UEProtoFile,
)


@dataclass(frozen=True, slots=True)
class GeneratedFile:
    """Represents a generated output file from the renderer."""

    name: str
    content: str


class ITemplateRenderer(Protocol):
    """Interface for renderers that convert :class:`UEProtoFile` objects into files."""

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        """Render the provided :class:`UEProtoFile` into zero or more files."""
        raise NotImplementedError


class DefaultTemplateRenderer:
    """Simple renderer that produces a header and source file per proto file."""

    def __init__(
        self,
        *,
        header_suffix: str = ".proto2ue.h",
        source_suffix: str = ".proto2ue.cpp",
    ) -> None:
        self._header_suffix = header_suffix
        self._source_suffix = source_suffix

    def render(self, ue_file: UEProtoFile) -> Iterable[GeneratedFile]:
        base_name = self._base_name_for(ue_file.name)
        header_name = f"{base_name}{self._header_suffix}"
        source_name = f"{base_name}{self._source_suffix}"
        registration_symbol = self._registration_symbol(base_name)
        header_content = self._render_header(header_name, ue_file)
        source_content = self._render_source(header_name, registration_symbol, ue_file)
        return [
            GeneratedFile(name=header_name, content=header_content),
            GeneratedFile(name=source_name, content=source_content),
        ]

    def _base_name_for(self, proto_name: str) -> str:
        if proto_name.endswith(".proto"):
            return proto_name[:-6]
        return proto_name

    def _render_header(self, header_name: str, ue_file: UEProtoFile) -> str:
        lines: List[str] = []
        lines.append("#pragma once")
        lines.append("")
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append("")
        lines.append('#include "CoreMinimal.h"')
        generated_include = self._generated_header_include(header_name)
        if generated_include is not None:
            lines.append(f'#include "{generated_include}"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        lines.extend(self._begin_ue_namespaces(namespace_stack))
        if namespace_stack:
            lines.append("")

        enums = self._collect_enums(ue_file)
        for enum in enums:
            lines.extend(self._render_enum(enum, indent_level=len(namespace_stack)))
            lines.append("")

        # fmt: off
        optional_wrappers = self._collect_optional_wrappers(ue_file)
        rendered_wrappers: set[int] = set()

        messages = self._sorted_messages(ue_file)
        message_names = {message.ue_name for message in messages}
        rendered_messages: set[str] = set()

        def emit_wrapper(wrapper: UEOptionalWrapper) -> None:
            wrapper_id = id(wrapper)
            if wrapper_id in rendered_wrappers:
                return
            base_type = wrapper.base_type
            if base_type in message_names and base_type not in rendered_messages:
                raise RuntimeError(
                    "Optional wrapper emitted before base message definition: "
                    f"{wrapper.ue_name} depends on {base_type}"
                )
            lines.extend(
                self._render_optional_wrapper(wrapper, indent_level=len(namespace_stack))
            )
            lines.append("")
            rendered_wrappers.add(wrapper_id)

        for idx, message in enumerate(messages):
            needed_wrappers: List[UEOptionalWrapper] = []
            for field in message.fields:
                if field.optional_wrapper is not None:
                    needed_wrappers.append(field.optional_wrapper)
            seen_wrapper_ids: set[int] = set()
            unique_wrappers: List[UEOptionalWrapper] = []
            for wrapper in needed_wrappers:
                wrapper_id = id(wrapper)
                if wrapper_id in seen_wrapper_ids:
                    continue
                seen_wrapper_ids.add(wrapper_id)
                unique_wrappers.append(wrapper)
            for wrapper in unique_wrappers:
                emit_wrapper(wrapper)

            lines.extend(self._render_message(message, indent_level=len(namespace_stack)))
            rendered_messages.add(message.ue_name)
            if idx != len(messages) - 1:
                lines.append("")

        for wrapper in optional_wrappers:
            if id(wrapper) not in rendered_wrappers:
                emit_wrapper(wrapper)
        # fmt: on

        if namespace_stack:
            lines.append("")
            lines.extend(self._end_ue_namespaces(namespace_stack))

        return "\n".join(lines) + "\n"

    def _generated_header_include(self, header_name: str) -> str | None:
        if not header_name.endswith(".h"):
            return None
        return f"{header_name[:-2]}.generated.h"

    def _render_source(
        self, header_name: str, registration_symbol: str, ue_file: UEProtoFile
    ) -> str:
        lines: List[str] = []
        lines.append(f"// Generated by proto2ue. Source: {ue_file.name}")
        lines.append(f'#include "{header_name}"')
        lines.append("")

        namespace_stack = self._namespace_stack(ue_file.package)
        lines.extend(self._begin_ue_namespaces(namespace_stack))
        if namespace_stack:
            lines.append("")

        indent = self._indent_for_namespace(namespace_stack)
        lines.append(f"{indent}namespace proto2ue {{")
        lines.append(f"{indent}    void {registration_symbol}() {{}}")
        lines.append(f"{indent}}}  // namespace proto2ue")

        if namespace_stack:
            lines.append("")
            lines.extend(self._end_ue_namespaces(namespace_stack))

        return "\n".join(lines) + "\n"

    def _begin_ue_namespaces(self, namespace_stack: List[str]) -> List[str]:
        lines: List[str] = []
        for depth, namespace in enumerate(namespace_stack):
            indent = "    " * depth
            lines.append(f"{indent}UE_NAMESPACE_BEGIN({namespace})")
        return lines

    def _end_ue_namespaces(self, namespace_stack: List[str]) -> List[str]:
        lines: List[str] = []
        for depth, namespace in reversed(list(enumerate(namespace_stack))):
            indent = "    " * depth
            lines.append(f"{indent}UE_NAMESPACE_END({namespace})")
        return lines

    def _indent_for_namespace(self, namespace_stack: List[str]) -> str:
        return "    " * len(namespace_stack)

    def _render_enum(self, enum: UEEnum, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        specifiers = self._format_macro_specifiers(
            blueprint=enum.blueprint_type,
            specifiers=enum.specifiers,
            category=enum.category,
            metadata=enum.metadata,
        )
        if specifiers:
            macro_line = f"{indent}UENUM{specifiers}"
        else:
            macro_line = f"{indent}UENUM()"
        lines = [macro_line]
        lines.append(f"{indent}enum class {enum.ue_name} : int32 {{")
        for value in enum.values:
            lines.append(f"{indent}    {value.name} = {value.number},")
        lines.append(f"{indent}}};")
        return lines

    def _render_optional_wrapper(
        self, wrapper: UEOptionalWrapper, *, indent_level: int
    ) -> List[str]:
        indent = "    " * indent_level
        lines: List[str] = []
        struct_specifiers = self._format_macro_specifiers(
            blueprint=wrapper.blueprint_type,
            specifiers=[],
            category=None,
            metadata={},
        )
        if struct_specifiers:
            lines.append(f"{indent}USTRUCT{struct_specifiers}")
        else:
            lines.append(f"{indent}USTRUCT()")
        lines.append(f"{indent}struct {wrapper.ue_name} {{")
        lines.append(f"{indent}    GENERATED_BODY()")
        if wrapper.blueprint_type:
            lines.append(f"{indent}    UPROPERTY(BlueprintReadWrite)")
        else:
            lines.append(f"{indent}    UPROPERTY()")
        lines.append(f"{indent}    bool {wrapper.is_set_member} = false;")
        if wrapper.value_blueprint_exposed:
            lines.append(f"{indent}    UPROPERTY(BlueprintReadWrite)")
        else:
            lines.append(f"{indent}    UPROPERTY()")
        lines.append(f"{indent}    {wrapper.base_type} {wrapper.value_member}{{}};")
        lines.append(f"{indent}}};")
        return lines

    def _registration_symbol(self, base_name: str) -> str:
        """Create a unique registration function name for a generated source file."""

        import re

        sanitized = re.sub(r"[^0-9A-Za-z_]", "_", base_name)
        if not sanitized:
            sanitized = "file"
        if sanitized[0].isdigit():
            sanitized = f"_{sanitized}"
        return f"RegisterGeneratedTypes_{sanitized}"

    def _render_message(self, message: UEMessage, *, indent_level: int) -> List[str]:
        indent = "    " * indent_level
        struct_specifiers = self._format_macro_specifiers(
            blueprint=message.blueprint_type,
            specifiers=message.struct_specifiers,
            category=message.category,
            metadata=message.struct_metadata,
        )
        lines: List[str] = []
        if struct_specifiers:
            lines.append(f"{indent}USTRUCT{struct_specifiers}")
        else:
            lines.append(f"{indent}USTRUCT()")
        lines.append(f"{indent}struct {message.ue_name} {{")
        lines.append(f"{indent}    GENERATED_BODY()")
        if message.fields:
            for field in message.fields:
                specifiers = self._format_property_specifiers(field)
                if specifiers is not None:
                    if specifiers:
                        lines.append(f"{indent}    UPROPERTY({specifiers})")
                    else:
                        lines.append(f"{indent}    UPROPERTY()")
                lines.append(f"{indent}    {field.ue_type} {field.name}{{}};")
        else:
            lines.append(f"{indent}    // No fields declared.")
        for oneof in message.oneofs:
            case_names = ", ".join(case.field.name for case in oneof.cases)
            lines.append(f"{indent}    // oneof {oneof.name}: {case_names}")
        lines.append(f"{indent}}};")
        return lines

    def _format_macro_specifiers(
        self,
        *,
        blueprint: bool,
        specifiers: List[str],
        category: str | None,
        metadata: Dict[str, str],
    ) -> str:
        items: List[str] = []
        if blueprint:
            items.append("BlueprintType")
        items.extend(self._dedupe_preserve_order(specifiers))
        meta_entries: List[str] = []
        metadata_items = metadata or {}
        if metadata_items:
            meta_entries.extend(
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(metadata_items.items())
            )
        if category and "Category" not in metadata_items:
            meta_entries.append(f'Category="{self._escape_metadata_value(category)}"')
        if meta_entries:
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items:
            return ""
        return f"({', '.join(items)})"

    def _format_property_specifiers(self, field: UEField) -> str | None:
        items: List[str] = []
        if field.blueprint_exposed:
            items.append(
                "BlueprintReadOnly"
                if field.blueprint_read_only
                else "BlueprintReadWrite"
            )
        items.extend(self._dedupe_preserve_order(field.uproperty_specifiers))
        if field.category:
            items.append(f'Category="{self._escape_metadata_value(field.category)}"')
        if field.uproperty_metadata:
            meta_entries = [
                f'{key}="{self._escape_metadata_value(value)}"'
                for key, value in sorted(field.uproperty_metadata.items())
            ]
            items.append(f"meta=({', '.join(meta_entries)})")
        if not items and not field.blueprint_exposed:
            return ""
        return ", ".join(items)

    def _escape_metadata_value(self, value: str) -> str:
        """Escape a value for safe inclusion in a C++ string literal."""

        escaped_chars = {
            "\\": "\\\\",
            '"': '\\"',
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
        }
        return "".join(escaped_chars.get(ch, ch) for ch in value)

    def _dedupe_preserve_order(self, specifiers: Iterable[str]) -> List[str]:
        seen = set()
        result: List[str] = []
        for specifier in specifiers:
            if specifier in seen:
                continue
            seen.add(specifier)
            result.append(specifier)
        return result

    def _collect_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        collected: List[UEMessage] = []

        def visit(message: UEMessage) -> None:
            for nested in message.nested_messages:
                visit(nested)
            collected.append(message)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _sorted_messages(self, ue_file: UEProtoFile) -> List[UEMessage]:
        messages = self._collect_messages(ue_file)
        if not messages:
            return []

        message_map = {message.ue_name: message for message in messages}
        dependencies = {
            message.ue_name: self._message_dependencies(message, message_map)
            for message in messages
        }

        temp_mark: set[str] = set()
        perm_mark: set[str] = set()
        ordered: List[str] = []
        has_cycle = False

        def visit(name: str) -> None:
            nonlocal has_cycle
            if name in perm_mark or has_cycle:
                return
            if name in temp_mark:
                has_cycle = True
                return
            temp_mark.add(name)
            for dep in dependencies.get(name, []):
                visit(dep)
            temp_mark.remove(name)
            perm_mark.add(name)
            ordered.append(name)

        for message in messages:
            if message.ue_name not in perm_mark:
                visit(message.ue_name)

        if has_cycle:
            return messages

        return [message_map[name] for name in ordered if name in message_map]

    def _message_dependencies(
        self, message: UEMessage, message_map: Dict[str, UEMessage]
    ) -> List[str]:
        dependencies: List[str] = []

        def record(candidate: Optional[str]) -> None:
            if candidate and candidate in message_map and candidate != message.ue_name:
                dependencies.append(candidate)

        for field in message.fields:
            for candidate in self._field_dependency_types(field):
                record(candidate)

        return self._dedupe_preserve_order(dependencies)

    def _field_dependency_types(self, field: UEField) -> List[str]:
        candidates: List[str] = []
        candidates.append(field.base_type)
        if field.map_key_type is not None:
            candidates.append(field.map_key_type)
        if field.map_value_type is not None:
            candidates.append(field.map_value_type)
        if field.optional_wrapper is not None:
            candidates.append(field.optional_wrapper.base_type)
        return [candidate for candidate in candidates if candidate]

    def _collect_enums(self, ue_file: UEProtoFile) -> List[UEEnum]:
        collected: List[UEEnum] = []
        collected.extend(ue_file.enums)

        def visit(message: UEMessage) -> None:
            collected.extend(message.nested_enums)
            for nested in message.nested_messages:
                visit(nested)

        for message in ue_file.messages:
            visit(message)
        return collected

    def _collect_optional_wrappers(
        self, ue_file: UEProtoFile
    ) -> List[UEOptionalWrapper]:
        return list(ue_file.optional_wrappers)

    def _namespace_stack(self, package: str | None) -> List[str]:
        if not package:
            return []
        return package.split(".")


__all__ = [
    "DefaultTemplateRenderer",
    "GeneratedFile",
    "ITemplateRenderer",
]
