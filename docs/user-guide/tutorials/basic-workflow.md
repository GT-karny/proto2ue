# 基本ワークフロー・チュートリアル

このチュートリアルでは、`proto2ue` がどのように proto2 スキーマを解析し、Unreal Engine で扱いやすいデータ構造へマッピングしてヘッダー／ソースのスケルトンを生成するのかを段階的に確認します。中間表現の確認と合わせて、実際に出力される C++ コードの読み解き方も紹介します。

## 1. サンプル proto の準備

`inventory.proto` というファイルを作成し、次のようなメッセージと列挙型を定義します。

```proto
syntax = "proto2";

package tutorial;

enum ItemRarity {
  COMMON = 0;
  RARE = 1;
  LEGENDARY = 2;
}

message ItemStat {
  required string name = 1;
  optional int32 value = 2;
}

message InventoryItem {
  required string id = 1;
  required ItemRarity rarity = 2;
  optional string display_name = 3;
  repeated ItemStat stats = 4;
  map<string, string> metadata = 5;

  oneof owner {
    string player_id = 6;
    string npc_id = 7;
  }
}
```

`proto2ue` は `map` フィールドを内部的にメッセージへ展開し、`oneof` に対しても UE 側で扱いやすいラッパー (将来の拡張) を生成できるようメタデータを付与します。

## 2. Descriptor の解析

リポジトリルートで以下のコマンドを実行し、`proto2ue` プラグインを通じて Descriptor が正しく処理されるか確認します。

```bash
export PYTHONPATH="$(pwd)/src:${PYTHONPATH}"

cat <<'SCRIPT' > ./protoc-gen-proto2ue
#!/usr/bin/env bash
PYTHONPATH="${PYTHONPATH}" python -m proto2ue.plugin "$@"
SCRIPT
chmod +x ./protoc-gen-proto2ue

protoc \
  --plugin=protoc-gen-proto2ue="$(pwd)/protoc-gen-proto2ue" \
  --proto2ue_out=/tmp/proto2ue-out \
  --proto_path=. \
  inventory.proto
```

`/tmp/proto2ue-out` には `inventory.proto2ue.h` と `inventory.proto2ue.cpp` が生成されます。以降のステップではこれらのファイルを参照します。

## 3. TypeMapper を用いた名称・型の確認

`TypeMapper` クラスは、Descriptor から得られた中間モデルを Unreal Engine 向けの表現 (`UEProtoFile`, `UEMessage`, `UEEnum` など) に変換します。以下のスクリプトを実行して結果をダンプしてみましょう。

```python
from pathlib import Path
from google.protobuf import descriptor_pb2
from proto2ue.descriptor_loader import DescriptorLoader
from proto2ue.type_mapper import TypeMapper

# descriptor_set.pb を生成
import subprocess
subprocess.run(
    [
        "protoc",
        "--descriptor_set_out=descriptor_set.pb",
        "--include_imports",
        "--proto_path=.",
        "inventory.proto",
    ],
    check=True,
)

request = descriptor_pb2.FileDescriptorSet()
request.ParseFromString(Path("descriptor_set.pb").read_bytes())

# protoc プラグインから渡される CodeGeneratorRequest を模倣
codegen_request = descriptor_pb2.compiler.plugin_pb2.CodeGeneratorRequest()
codegen_request.proto_file.extend(request.file)
codegen_request.file_to_generate.append("inventory.proto")

loader = DescriptorLoader(codegen_request)
proto_file = loader.get_file("inventory.proto")

mapper = TypeMapper()
ue_file = mapper.map_file(proto_file)

for message in ue_file.messages:
    print(f"Message: {message.ue_name}")
    for field in message.fields:
        attrs = []
        if field.is_optional:
            attrs.append("optional")
        if field.is_repeated:
            attrs.append("repeated")
        if field.is_map:
            attrs.append("map")
        attrs_str = f" ({', '.join(attrs)})" if attrs else ""
        print(f"  - {field.name} -> {field.ue_type}{attrs_str}")
    if message.oneofs:
        print("  Oneof groups:")
        for oneof in message.oneofs:
            print(f"    * {oneof.ue_name}")
            for case in oneof.cases:
                print(f"      - {case.field.name} -> {case.field.ue_type}")
```

実行結果の例:

```
Message: FInventoryItem
  - id -> FString
  - rarity -> ETutorialItemRarity
  - display_name -> TOptional<FString> (optional)
  - stats -> TArray<FItemStat> (repeated)
  - metadata -> TMap<FString, FString> (map)
  - player_id -> FString
  - npc_id -> FString
  Oneof groups:
    * FInventoryItemOwnerOneof
      - player_id -> FString
      - npc_id -> FString
Message: FItemStat
  - name -> FString
  - value -> TOptional<int32> (optional)
```

- `F` / `E` というプレフィックスは Unreal Engine のコーディング規約に合わせたものです。
- `optional` フィールドは `TOptional` ラッパーで、`repeated` フィールドは `TArray` にマッピングされます。
- `map<string, string>` は `TMap<FString, FString>` に展開され、キー・値の型は `TypeMapper` が自動決定します。
- `oneof owner` は UE 用のラッパー構造 (`FInventoryItemOwnerOneof`) を生成する準備が整っており、各ケースが `UEOneofCase` に対応します。

## 4. 生成された C++ コードを確認する

`proto2ue.codegen.DefaultTemplateRenderer` は上記の中間表現から UE 向けヘッダー／ソースを作成します。`inventory.proto2ue.h` の抜粋は以下の通りです。

```cpp
#pragma once

// Generated by proto2ue. Source: inventory.proto

#include "CoreMinimal.h"
#include "inventory.proto2ue.generated.h"

namespace tutorial {

UENUM(BlueprintType)
enum class ETutorialItemRarity : int32 {
    COMMON = 0,
    RARE = 1,
    LEGENDARY = 2,
};

USTRUCT(BlueprintType)
struct FItemStat {
    GENERATED_BODY()
    UPROPERTY(BlueprintReadWrite)
    FString name{};
    UPROPERTY(BlueprintReadWrite)
    TOptional<int32> value{};
};

USTRUCT(BlueprintType)
struct FInventoryItem {
    GENERATED_BODY()
    UPROPERTY(BlueprintReadWrite)
    FString id{};
    UPROPERTY(BlueprintReadWrite)
    ETutorialItemRarity rarity{};
    UPROPERTY(BlueprintReadWrite)
    TOptional<FString> display_name{};
    UPROPERTY(BlueprintReadWrite)
    TArray<FItemStat> stats{};
    UPROPERTY(BlueprintReadWrite)
    TMap<FString, FString> metadata{};
    UPROPERTY(BlueprintReadWrite)
    FString player_id{};
    UPROPERTY(BlueprintReadWrite)
    FString npc_id{};
    // oneof owner: player_id, npc_id
};

}  // namespace tutorial
```

対応する `inventory.proto2ue.cpp` には、将来的にモジュール初期化と統合する `proto2ue::RegisterGeneratedTypes_inventory` スタブが出力されます。現段階では空実装ですが、生成ファイルを UE モジュールに組み込んだ際の登録フックとして利用する想定です。

## 5. UE への組み込みを見据えたベストプラクティス

- **命名衝突の回避**: proto のパッケージ階層は UE 側の名前空間に変換されません。衝突が懸念される場合は `TypeMapper` のプレフィックス設定をカスタマイズする予定です。
- **カスタムオプション**: `DescriptorLoader` はフィールド／メッセージ／列挙型のオプションを保持します。将来のコード生成で `BlueprintType` 等のメタデータにマップできるよう、proto 側の注釈を整備しておくとスムーズです。
- **依存管理**: UE プロジェクトに統合する際は、`protoc` 実行時の `--proto_path` を Unreal Build Tool のヘッダー検索パスと同期させるとビルドトラブルを避けられます。

## 6. 次のステップ

- 変換結果を検証する自動テストは `tests/` 以下のサンプルを参考に追加できます。
- 生成コードのテンプレートが整備された際には、本チュートリアルを拡張して「ビルドできる UE モジュール」を導く予定です。
- サンプル UE プロジェクトは今後公開予定のため、本チュートリアルではコードスニペットで代替しています。

フィードバックや改善提案があれば Issue / Pull Request でお知らせください。
